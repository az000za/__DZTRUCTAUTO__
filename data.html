<html>
    <body id="root"></body>
    <script type="text/javascript" filename="data.html">
      DataNodeAWebExpressionBaseStruct
      class DNAWEB {
        /*
            Progressive Self Optimizing DataStructure that adapts innerworking of queries.
            Default Storage Patterns are 
            a single array with what ever elementInterface.
    
            Transforms into a multiLinkedNodeWebTree
        */
        // Constructor to initialize data properties
          constructor(config) {
            this._interface(config);
          }
          _interface = class Interface {
              constructor(config){
                const _ = {
                  orderlyChaos: {},
                  id: {},//uuidv4(); // Unique identifier for each data instance
                  value:{},
                  fieldname:{},
                  key:{},
                  index: {},
                  description:{},
                  type:{},
                  immutable:{},
                  searchable: {},
                  readable: {},
                  writable: {},
                  updateable: {},
                  deletable: {},
                  backupable: {},
                  extendable: {},
                  encode: {},
                  auth: {},
                  transmittable: {},
                  encrypt: {},
                  compress: {},
                  renderable: {},
                  priority: {},
                  origin: {},
                  metadata: {},
                  validationRules: {},
                  dependencies: {},
                  visualizationType: {},
                  accessRestrictions: {},
                  changeHistory: {},
                  qualityIndicators: {},
                  usageStatistics: {},
                  defaultValue: {},
                  required: {},
                  description: {},
                  rangeConstraint: {},
                  patternConstraint: {},
                  enumerationConstraint: {},
                  referentialIntegrityConstraint: {},
                  dataValidationConstraint: {},
                  subscribeable: {},
                  memory: {},
                  autoSort: {},
                  sortCriteria: {},
                  accuracy: {},
                  completeness: {},
                  consistency: {},
                  relevance: {},
                  granularity: {},
                  auditability: {},
                  accessibility: {},
                  security: {},
                  privacy: {},
                  dataLineage: {},
                  dataSensitivity: {},
                  dataGovernance: {},
                  dataExpiration: {},
                  dataUsageMetrics: {},
                  dataAnnotations: {},
                  dataQualityScore: {},
                  dataVersioning: {},
                  domain: {},
                  standardization: {},
                  versioning: {},
                  interpretability: {},
                  actionability: {},
                  tags: {},
                  source: {},
                  format: {},
                  lifecycle: {},
                  owner: {},
                  lastUpdated: {},
                  notes: {},
                  type: {},
                  required: {},
                  index: {},
                  unique: {},
                  default: {},
                  get: {},
                  set: {},
                  validate: {},
                  sparse: {},
                  expires: {},
                  select: {},
                  populate: {},
                  trim: {}, // min: This property specifies the minimum value for a number field.
                  max: {}, // This property specifies the maximum value for a number field.
                  enum: {}, // This property specifies a list of allowed values for a field.
                  ref: {}, //: This property specifies the name of another model that the field should reference.
                  discriminator: {},//This property specifies a discriminator key that can be used to differentiate between different types of documents in the same collection.
                };
                this.configKeysMatchInterface(config);
                this.configKeysValidValues(config);
                this.setConfigToThis(config);
                this.saveConfig(config);
            }
            configKeysMatchInterface(){
              const config_keys = Object.keys(config);  const interface_keys = Object.keys(_interface);
              const config_length = config_keys.length; const interface_length = interface_keys.length;
              if (config_length !== interface_length) {
                throw new Error("config & interface not equal length");
              }
              const config_keys_sorted = config_keys.sort();
              const interface_keys_sorted = interface_keys.sort();
              const config_keys_sorted_string = config_keys_sorted.join("");
              const interface_keys_sorted_string = interface_keys_sorted.join("");
              if (config_keys_sorted_string !== interface_keys_sorted_string) {
                throw new Error("config & interface not matching keys");
              }
            }
            configKeysValidValues(){
              for (let key in _interface) {
                const value = config[key];
                let isValid = false;
                isValid = _interface[key].validate(invalidated);
                if (/*not valid*/!isValid) {
                  throw new Error("value not valid")
                }
              }
            }
            setConfigToThis(){
              for (let key in _interface) {
                const value = config[key];
                this[key] = config[key];
              }
            }
            saveConfig(){
              console.log("need to program save");
            }
        }
        dataStructureCharacteristics = class DataStructureCharacteristics {
          organization() {
            console.log("Data structures organize data in a specific way for efficient storage and retrieval.");
          }
          storage () {
            console.log("Data structures store data in a computer's memory, allocating space and managing its placement.");
          }
          management() {
            console.log("Data structures provide mechanisms for managing data, including insertion, deletion, searching, and sorting.");
          }
          abstraction() {
            console.log("Data structures abstract away low-level memory management details, focusing on logical data organization and manipulation.");
          }
          efficiency() {
            console.log("Data structures are designed to be efficient in memory and processing time, minimizing access, search, and manipulation operations.");
          }
          applicationSpecific() {
            console.log("The choice of data structure depends on the specific application and data type, with different strengths and weaknesses for different purposes.");
          }
          problemSolvingTool() {
            console.log("Data structures are fundamental problem-solving tools, providing efficient data storage, management, and manipulation for effective software development.");
          }
        };

        // Method to convert the data to a specific format
        convert(format) {
          // Implement data conversion logic based on the specified format
          if (format === "json") {
            return JSON.stringify(this);
          } else {
            // Handle other supported formats here
          }
        }
        // Method to query the data using a filter function
        IO = class IO{
          constructor(data){
              // double filter
              this.filter(data);
              this.query(data);
              this.filter(data);
              
          }
          input(data) {
            
          }
          output(data) {
            
          }
        }
        query = class Query {
          // select,
          // sort
          // groupBy,
          // filter,
          // Implement data filtering logic using the provided filter function
          // Return the filtered data or an error if the filter function is invalid
          constructor(){
            new this.Assign(...arguments);
            new this.Cruds(...arguments);
            new this.Select(...arguments);
            new this.Sort(...arguments);
            new this.GroupBy(...arguments);
            new this.Filter(...arguments);
            new this.Send(...arguments);
          }
        }
        Assign(){

        }
        // CRUD operations (moved outside of query() method)
        crud = class Cruds {
          constructor(obj){
            obj
          }
          set(){}
          // Create: Add a new data item
          // Read: Retrieve an existing data item
          read(identifier) {
            // Implement logic to retrieve the data item with the specified identifier
            // Return the retrieved data item or an error if not found
          }
          // Update: Modify an existing data item
          update(identifier, updatedData) {
            // Implement logic to update the data item with the specified identifier
            // Return the updated data item or an error if not found
          }        
          // Delete: Remove an existing data item
          delete(identifier) {
            // Implement logic to remove the data item with the specified identifier
            // Return a success message or an error if not found
          }
        }
        Select(){}
        Sort(){}
        GroupBy(){}
        Filter(){}
        Send(){}
        ops = class NumXAlgoEngine {  // numX is in place of the data.
          constructor() {
              console.log(`
                  NumXAlgo is a lazy evaluation datastructure.
                  The NumXalgo Datastructure contains actions
                  to be performed on the number.
                  Once the data is requested, it will optimize
                  the actions needed by ruling out redundandcies,
                  and then execute the actions to return the
                  the requested output.

                  NumXAlgo is the main datastructure that the data will be in.
                  Y?
                  Because the outputs of data are different than
                  the way data is operated on
                  and the way data is stored.
                  this.storagePattern
                  this.operatePattern
                  this.visualOutPattern
              `);
              // Initialize properties for different operators
              // this.operators = {
              // '+': 0,
              // '-': 0,
              // '*': 1, // Initialize to 1 for multiplication
              // '/': 1, // Initialize to 1 for division
              // '%': 0,
              // '**': 1, // Initialize to 1 for exponentiation
              // '++': 0,
              // '--': 0,
              // '!': 0,
              // '&&': true, // Initialize to true for logical AND
              // '||': false, // Initialize to false for logical OR
              // '^': 0, // Initialize to 0 for bitwise XOR
              // '==': false, // Initialize to false for equality
              // '!=': true, // Initialize to true for inequality
              // '>': false, // Initialize to false for greater than
              // '<': false, // Initialize to false for less than
              // '>=': false, // Initialize to false for greater than or equal
              // '<=': false, // Initialize to false for less than or equal
              // '<<': 0, // Initialize to 0 for left shift
              // // Add other operators as needed
              // };
              this.iter = 0;
              this.operations = [];
              this.operators = [
                {
                    operator: "()",
                    precedence: 1,
                    description: "Parentheses have the highest precedence. Expressions inside parentheses are evaluated first."
                },
                {
                    operator: "**",
                    precedence: 2,
                    description: "Exponentiation has higher precedence than multiplication and division."
                },
                {
                    operator: "*",
                    precedence: 3,
                    description: "Multiplication has higher precedence than addition and subtraction."
                },
                {
                    operator: "/",
                    precedence: 3,
                    description: "Division has higher precedence than addition and subtraction."
                },
                {
                    operator: "+",
                    precedence: 4,
                    description: "Addition has equal precedence with subtraction."
                },
                {
                    operator: "-",
                    precedence: 4,
                    description: "Subtraction has equal precedence with addition."
                },
                {
                    operator: "<",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "<",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: ">",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "<=",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: ">=",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "instanceof",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "in",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "==",
                    precedence: 6,
                    description: "Equality operators."
                },
                {
                    operator: "===",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "!=",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "!==",
                    precedence: 5,
                    description: "Relational operators."
                },
                {
                    operator: "&&",
                    precedence: 7,
                    description: "Logical AND (short-circuits if the left operand is falsy)."
                },
                {
                    operator: "||",
                    precedence: 8,
                    description: "Logical OR (short-circuits if the left operand is truthy)."
                },
                {
                    operator: "?:",
                    precedence: 9,
                    description: "Conditional (ternary) operator."
                },
                {
                    operator: "=",
                    precedence: 10,
                    description: "Assignment operators."
                },
                {
                    operator: "+=",
                    precedence: 10,
                    description: "Assignment operators."
                },
                {
                    operator: "-=",
                    precedence: 10,
                    description: "Assignment operators."
                },
                {
                    operator: "*=",
                    precedence: 10,
                    description: "Assignment operators."
                },
                {
                    operator: "/=",
                    precedence: 10,
                    description: "Assignment operators."
                },
                {
                    operator: ",",
                    precedence: 11,
                    description: "Comma operator (evaluates expressions from left to right and returns the rightmost value)."
                }
              ];

              for (let key in this.operators) {
                this[key] = ops[key];
              }
          }
          operate(operator, arg) {
              const operatorObj = this.operators.find((obj)=> obj.operator === operator);
              if (operatorObj) {
                  this.operations.push(
                    {
                      iter:       this.iter++,
                      operator:   operatorObj.operator,
                      precedence: operatorObj.precedence,
                      arg:        arg,
                    }
                  )
              } else {
                  console.error('Invalid operator:', operator);
              }
              return this;
          }
          optimize(){
            this.optimizeByInstructionRepetition();
            this.optimizeByInstructionRequest();
            this.optimizeByInstructionEquivalentConversion();
            // // Sort operations by precedence (ascending order) and entry order
            // this.operations.sort((a, b) => a.precedence - b.precedence);
            return this; // For method chaining
          }
          optimizeByInstructionRepetition(){
            // first optimizations lookups for repetitions. such as repetitional adds or multiplications
            // add(20)
            // add(20)
            // add(20)
            // { op: "add", value: 20, cnt: 3, value: 60}
            // add(5);
            // add(5);
            // { op: "add", value: 5, cnt: 2, value: 60}
            // multiply(2)
            // multiply(2)
            // multiply(2)
            // {op: "multiply", value: 2, cnt: 3, value: 6}
            // multiply(9);
            // mulltiply(9);
            // {op: "multiply" value: 9, cnt: 2, value: 18}
            
            this.crunchedInstructions = [];
            this.crunchedInstruction = {operator: this.operations[0].operator, value: this.operations[0].value, cnt: 1};
            this.operations.slice(1).forEach((opObj)=>{
              if (opObj.operator === crunchedInstruction.operator) {
                if (opObj.value === crunchedInstruction.value) {
                  crunchedInstruction.cnt++;
                }
              } else {
                crunchedInstructions.push(crunchedInstruction);
                crunchedInstruction = {
                  operator: opObj.operator,
                  value: opObj.value,
                  cnt: 1,
                }
              }
            });
          }
          optimizeByRequest(){
            /*when the datastructure needs to convert to a different datastructure*/
          }
          optimizeByInstructionEquivalentConverstion(){
            /*
            // add(20)
            // add(20)
            // add(20)
            // add(20)
            // equals mult(40, 2);
            // equals mult(20, 4);
            // equals mult(10, 8);
            // equals mult(5, 16);
            // equals mult(4, 20);
            // equals mult(2, 40);
            */
          }
          optimizeByInstructionSorting(){

          }
          optimizeByAtomizingToEquivalents(){
            // // mult(40, 2);   add(1, 80)
            //                   add(2, 40);
            //                   add(4, 20);
            //                   add(8, 10)
            // // mult(20, 4);   add(1, 80);
            //                   add(2, 40);
            //                   add(4, 20);
            //                   add(8, 10)

            mult(40,2) + mult(20, 40) equals add(2, 80);
          }
          convertToDStruct(dstruct){

          }
          execute(){

          }
          loop(cb, args, stopIf){
            if (!stopIf()) {

            } else {
              cb(...args);
            }
          }
        }
      };
      // };
  </script>
</html>
